"""
Image Generation Service - Google Gemini 2.0 Image Generation
Handles image generation using Google's Imagen 3 model via Gemini API
"""

import google.generativeai as genai
import base64
import logging
from typing import Dict, List
from datetime import datetime
import os
from pathlib import Path
import uuid
import aiohttp
from PIL import Image
import io

from ..config import get_settings

logger = logging.getLogger(__name__)
settings = get_settings()

# Configure Gemini API
genai.configure(api_key=settings.GOOGLE_GEMINI_API_KEY)


class ImageService:
    """
    Service for generating images using Google Gemini Imagen 3
    """
    
    def __init__(self):
        """Initialize the image generation service"""
        try:
            # Try to use Imagen 3 through the Google AI API
            self.imagen_model = genai.ImageGenerationModel("imagen-3.0-generate-001")
            self.use_imagen = True
            logger.info("ImageService initialized with Imagen 3.0")
        except Exception as e:
            logger.warning(f"Imagen 3.0 not available: {e}. Will use fallback service.")
            self.use_imagen = False
            
        self.image_dir = Path("uploads/generated_images")
        self.image_dir.mkdir(parents=True, exist_ok=True)
    
    async def generate_image(
        self,
        prompt: str,
        user_id: int = None
    ) -> Dict[str, str]:
        """
        Generate an image from text prompt using Imagen 3 or fallback service
        
        Args:
            prompt: The text description for image generation
            user_id: User ID for tracking
        
        Returns:
            Dictionary with image data and metadata
        """
        try:
            logger.info(f"Generating image: {prompt[:50]}...")
            
            if self.use_imagen:
                # Try using Imagen 3
                return await self._generate_with_imagen(prompt)
            else:
                # Use fallback service (Pollinations AI - free, no API key needed)
                return await self._generate_with_pollinations(prompt)
            
        except Exception as e:
            logger.error(f"Error in image generation: {str(e)}")
            
            # If Imagen failed, try fallback
            if self.use_imagen:
                logger.info("Falling back to Pollinations AI...")
                try:
                    return await self._generate_with_pollinations(prompt)
                except Exception as fallback_error:
                    logger.error(f"Fallback also failed: {fallback_error}")
            
            return {
                "success": False,
                "error": str(e),
                "message": f"âŒ I encountered an error while generating your image.\n\n**Your request:** {prompt}\n\n**Error:** {str(e)}\n\nPlease try again with a different prompt.",
                "timestamp": datetime.now().isoformat()
            }
    
    async def _generate_with_imagen(self, prompt: str) -> Dict[str, str]:
        """Generate image using Google Imagen 3"""
        result = self.imagen_model.generate_images(
            prompt=prompt,
            number_of_images=1,
            safety_filter_level="block_some",
            person_generation="allow_adult",
            aspect_ratio="1:1",
        )
        
        if result.images and len(result.images) > 0:
            image = result.images[0]
            image_filename = f"{uuid.uuid4()}.png"
            image_path = self.image_dir / image_filename
            image._pil_image.save(str(image_path))
            
            logger.info(f"Image generated with Imagen 3: {image_filename}")
            image_url = f"/uploads/generated_images/{image_filename}"
            
            return {
                "success": True,
                "image_url": image_url,
                "message": f"ðŸŽ¨ Image generated successfully with Google Imagen 3!\n\n**Prompt:** {prompt}",
                "is_image": True,
                "model": "imagen-3.0",
                "original_request": prompt,
                "timestamp": datetime.now().isoformat()
            }
        else:
            raise Exception("No image was generated by Imagen")
    
    async def _generate_with_pollinations(self, prompt: str) -> Dict[str, str]:
        """Generate image using Pollinations AI (free fallback)"""
        # Pollinations AI API - free, no API key needed
        # https://pollinations.ai/
        import urllib.parse
        encoded_prompt = urllib.parse.quote(prompt)
        
        # Use their API to generate image
        url = f"https://image.pollinations.ai/prompt/{encoded_prompt}?width=1024&height=1024&nologo=true"
        
        logger.info(f"Generating image with Pollinations AI...")
        
        async with aiohttp.ClientSession() as session:
            async with session.get(url) as response:
                if response.status == 200:
                    image_data = await response.read()
                    
                    # Save the image
                    image_filename = f"{uuid.uuid4()}.png"
                    image_path = self.image_dir / image_filename
                    
                    # Convert and save as PNG
                    img = Image.open(io.BytesIO(image_data))
                    img.save(str(image_path), 'PNG')
                    
                    logger.info(f"Image generated with Pollinations AI: {image_filename}")
                    image_url = f"/uploads/generated_images/{image_filename}"
                    
                    return {
                        "success": True,
                        "image_url": image_url,
                        "message": f"ðŸŽ¨ Image generated successfully!\n\n**Prompt:** {prompt}",
                        "is_image": True,
                        "model": "pollinations-ai",
                        "original_request": prompt,
                        "timestamp": datetime.now().isoformat()
                    }
                else:
                    raise Exception(f"Pollinations API returned status {response.status}")
    
    def detect_image_request(self, message: str) -> bool:
        """
        Detect if the user is requesting image generation
        
        Args:
            message: User's message
            
        Returns:
            True if message contains image generation keywords
        """
        # Direct patterns that indicate image generation
        direct_patterns = [
            "generate an image", "generate image", "create an image", "create image",
            "make an image", "make image", "draw an image", "draw image",
            "generate a picture", "create a picture", "make a picture",
            "generate a photo", "create a photo", "make a photo",
            "show me an image", "show me a picture", "show me an illustration"
        ]
        
        message_lower = message.lower()
        
        # Check direct patterns first
        if any(pattern in message_lower for pattern in direct_patterns):
            return True
        
        # Check if starts with "draw" (common pattern: "draw me a...", "draw a...")
        if message_lower.startswith("draw "):
            return True
        
        # Check for action + image word combination
        keywords = ["generate", "create", "make", "show me"]
        image_words = ["image", "picture", "photo", "pic", "illustration", "drawing", "artwork"]
        
        has_action = any(keyword in message_lower for keyword in keywords)
        has_image_word = any(word in message_lower for word in image_words)
        
        return has_action and has_image_word


# Singleton instance
_image_service = None

def get_image_service() -> ImageService:
    """Get or create the image service singleton"""
    global _image_service
    if _image_service is None:
        _image_service = ImageService()
    return _image_service
